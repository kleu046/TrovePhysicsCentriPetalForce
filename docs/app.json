[{"name": "app.py", "content": "from shiny.express import input, render, ui\nfrom shiny import reactive\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib.patches import Circle, Rectangle\nimport time\n\ntime_min: float = 0\ntime_max: float = 100\ntime_step: float = 1.5\n\nui.page_opts(title=\"Centripetal force\", fillable=True)\n\nwith ui.nav_panel(\"What is centripetal force?\"):\n    with ui.layout_sidebar():\n        with ui.sidebar(bg='#29e004'):\n            ui.input_slider(\"time\", \"Animate\", min=time_min, max=time_max,value=time_min, step=time_step, animate=True,)\n\n        with ui.card(height = 700):\n            def calc_pos(r: float, w: float, t: float) -> (float, float):\n                return r * np.cos(w * t), r* np.sin(w * t)\n\n            def calc_velocity_vector(r: float, w: float, t:float) -> (float, float):\n                return -w * r * np.sin(w * t), w * r * np.cos(w * t)\n\n            plot_width: float = 100.0\n            plot_height: float = 100.0\n            box_width: float = 30.0\n            box_height: float = 30.0\n            edge_color: str = 'green'\n            face_color: str = 'white'\n            path_radius: float = 80\n            obj_radius: float = 10\n            obj_lw: float = 5\n\n            fig_size: tuple = (10, 12)\n            obj_omega: float = 0.5 # angular velocity\n            lightgrey: list = ['#888888','#999999','#aaaaaa','#bbbbbb','#cccccc','#dddddd','#eeeeee','#ffffff']\n            \n            def create_circle(centre: (float,float), obj_radius: float, **kwargs) -> matplotlib.patches.Circle:\n                return Circle(centre, radius=obj_radius, lw=obj_lw, **kwargs)\n\n            centre_x: float = path_radius\n            centre_y: float = 0\n\n            x = np.linspace(-path_radius, path_radius, 100)\n            y = [np.sqrt(path_radius**2 - x_e**2) for x_e in x]\n            path_x = np.hstack([x, x[::-1]])\n            path_y = np.hstack([y,  [-1 * y_e for y_e in y][::-1]])\n\n            v_x: float = 0\n            v_y: float = obj_omega * path_radius\n\n            @reactive.effect\n            @reactive.event(input.time)\n            def set_pos() -> None:\n                # calculate centre_x and centre_y using input.time\n                global centre_x\n                global centre_y\n                \n                t: float = float(input.time())\n                centre_x, centre_y_new = calc_pos(path_radius, obj_omega, t)\n                if (centre_y_new > 0 and centre_y < 0) or ((input.time() - time_step) >= len(lightgrey)):\n                    centre_y = 0\n                    centre_x = path_radius\n                    ui.update_slider('time',value=0)\n                else:\n                    centre_y = centre_y_new\n\n            @reactive.effect\n            @reactive.event(input.time)\n            def set_velocity_vector() -> None:\n                global v_x\n                global v_y\n\n                t: float = float(input.time())\n                v_x, v_y = calc_velocity_vector(path_radius, obj_omega, t)\n\n            @render.plot\n            @reactive.event(input.time)\n            def plot() -> None:\n                # draw a small circle with a circular path\n                fig, ax = plt.subplots(figsize=fig_size)\n                ax.plot(path_x, path_y, lw=10, color='#f0ff0f', zorder=0)\n\n                t: float = float(input.time())\n                \n                counter = 0\n                n = t - time_step\n                while n > 0 and counter < len(lightgrey):\n                    grey_centre = calc_pos(path_radius, obj_omega, n)\n                    grey_circle = create_circle(grey_centre, obj_radius, facecolor = face_color, edgecolor =lightgrey[counter])\n                    ax.add_patch(grey_circle)\n                    \n                    grey_velocity = calc_velocity_vector(path_radius, obj_omega, n)\n                    ax.arrow(grey_centre[0] , grey_centre[1], dx=grey_velocity[0], dy=grey_velocity[1], shape='full', color=lightgrey[counter], lw=2, head_width=plot_width/50)\n                    n -= time_step\n                    counter += 1\n\n                circle = create_circle((centre_x, centre_y), obj_radius, facecolor = face_color, edgecolor = edge_color)\n                ax.add_patch(circle)\n\n                # demonsrate how centripetal acceleration points to the centre of the circel\n                if t == 0:\n                    xi, yi = calc_pos(path_radius, obj_omega, 4)\n                    v_xi, v_yi = calc_velocity_vector(path_radius, obj_omega, 4)\n                    xm, ym = calc_pos(path_radius, obj_omega, 2)\n                    v_xm, v_ym = calc_velocity_vector(path_radius, obj_omega, 2)\n\n                    # v(t)\n                    ax.arrow(xi , yi, dx=v_xi, dy=v_yi, shape='full', color='lightblue', lw=2, head_width=plot_width/40)\n                    ax.arrow(xm , ym, dx=v_xm, dy=v_ym, shape='full', color='lightblue', lw=2, head_width=plot_width/40)\n                    ax.arrow(xi , yi , dx = 0 - xi, dy = 0 - yi, color='lightgrey', ls='--')\n                    # v(0)\n                    ax.arrow(xm , ym , dx = (v_xi - v_x), dy = (v_yi - v_y), color='grey', head_width=plot_width/20)\n                    ax.arrow(xm , ym, dx=v_xi, dy=v_yi, shape='full', color='lightgrey', ls='--', lw=1, head_width=plot_width/40)\n                    ax.arrow(xm + v_xi , ym + v_yi, dx=-v_x, dy=-v_y, shape='full', color='lightgrey', ls='--', lw=1, head_width=plot_width/40)\n\n                    ax.text((xi + v_xi) * 1.4, (yi + v_yi), 'v(t=2)', fontdict={'size':12,'fontweight':'bold'})\n                    ax.text((xm + v_xm) * 1.4, (ym + v_ym), 'v(t=1)', fontdict={'size':12,'fontweight':'bold'})\n                    ax.text((xm + v_xi) * 2, (ym + v_yi), 'v(t=2) - v(t=0)', va='center', fontdict={'size':8})\n\n                    #ax.arrow(xm , ym , dx = 0 - xm, dy = 0 - ym, color='lightgrey', ls='--')\n                    \n                    \n                ax.arrow(centre_x, centre_y, dx=v_x, dy=v_y, shape='full', lw=2, head_width=plot_width/50)\n\n                v_label: str = 'v(t=0)' if t == 0 else 'v'\n                ax.text((centre_x + v_x) / 0.9, (centre_y + v_y) * 0.8, v_label, fontdict={'size':12,'fontweight':'bold'})\n\n                ax.arrow(centre_x, centre_y, dx=0-centre_x, dy=0-centre_y, shape='full', lw=3, head_width=plot_width/30)\n                ax.text((centre_x + v_x/2)* 0.5, (centre_y + v_y/2) * 0.5, 'a', fontdict={'size':12,'fontweight':'bold'})\n\n                if t > 0:\n                    time_label = f't={input.time()}'\n                    ax.text(80,90, time_label, ha='left', fontdict={'size':12,'fontweight':'bold'})\n\n                ax.set_xlim(-plot_width,plot_width)\n                ax.set_ylim(-plot_height,plot_height)\n                ax.set_aspect('equal')\n                \n                ax.axis('off')\n\n                return fig\n\n        with ui.card():\n            @render.text\n            def notes1():\n                return \"Centripetal force is not a fundamental force.  It is an apparent force as a result of an object in motion following a circular path.\"\n\n            @render.text\n            def notes2():\n                return \"By definition acceleration is change in velocity with respect to time.  As an object moves along a circular path at constant speed its direction changes constantly.  This means that velocity is constantly changing in direction, resulting in acceleration.\"\n\n            @render.text\n            def notes3():\n                return \"By drawing the velocity vectors v at a point on the circular path and again after time t, it can easily be shown that the  acceleration points toward the centre of the circular path.\"\n\n            @render.text\n            def notes4():\n                return \"At any point on the path of a circular motion, the acceleration point toward the centre, hence the term, centripetal.\"\n\n            @render.text\n            def notes5():\n                return \"To understand why centripetal force exist we must consider Newton\u2019s law of inertia.  If no net force is present, an object moving at velocity v tangential to the circular path will continue its path in a straight line at constant speed.  In this case, there would be no circular motion.\"\n\n            @render.text\n            def notes6():\n                return \"In order to deviate from the straight line there must be a net force acting on the object.  This force pulls the object toward the centre to maintain the circular motion.\"\n\nwith ui.nav_panel('Banked corners'):\n\n    def calc_y(x: float, angle: float) -> None:\n        if  angle <= 60:\n            return np.tan(rad(angle)) * x\n\n    def rad(angle: float) -> float:\n        return angle / 180 * np.pi\n\n    with ui.layout_sidebar():\n        \n        plot_width: float = 100.0\n        plot_height: float = 100.0\n        angle: float = 0\n        mu: float = 0.5\n        slope_x: np.array([float,float]) = np.array([0,100])\n        edge_color = 'black'\n        box_color = 'lightgrey'\n        box_height = 36\n        box_width = 15\n        anchor_x: float = (plot_width - box_width) / 2\n\n        with ui.sidebar(bg='#29e004'):\n\n            ui.input_slider(\"angle_slider\", \"Angle\", min=0, max=60, value=angle, step=1)\n            ui.input_slider(\"mu_slider\", \"Coefficient of friction\", min=0, max=1, value=mu, step=0.01)\n\n        def create_rectangle(anchor_x: float, _anchor_y: float, width: float, height: float, angle: float, facecolor = face_color, edgecolor = edge_color) -> matplotlib.patches.Rectangle:\n            return Rectangle((anchor_x, _anchor_y), width, height, angle=angle, lw=5, facecolor = facecolor, edgecolor = edgecolor) #use rotation_point parameter default = 'xy' = bottom left corner (x, y) available in later matplotlive versions?\n\n        with ui.card(height=700):        \n            @render.plot\n            @reactive.event(input.angle_slider, input.mu_slider)\n            def plot2() -> None:\n                angle: float = float(input.angle_slider())\n                mu: float = float(input.mu_slider())\n                \n                fig, ax = plt.subplots(figsize=(10,12))\n                print(int(input.angle_slider()))\n                ax.plot(slope_x, calc_y(slope_x, angle), lw=5, c='darkgrey', zorder=0)\n\n                x: float = anchor_x\n                y: float = calc_y(x, angle)\n\n                rect = create_rectangle(x, calc_y(anchor_x, angle), box_width, box_height, angle=angle, facecolor = box_color, edgecolor = edge_color) # angle in degrees\n                rect_bottom_centre_x = rect.get_x() + box_width/2 * np.cos(rad(angle))\n                rect_bottom_centre_y = calc_y(rect_bottom_centre_x, angle)\n\n                ax.add_patch(rect)\n\n                dy_std = 30\n\n                # weight\n                ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=0, dy=-dy_std, shape='full', lw=2, head_width=plot_width/50, color='grey')\n                ax.text(rect_bottom_centre_x + 2, rect_bottom_centre_y - 0.5 * dy_std, 'Weight', fontdict={'size':12})\n\n                # normal\n                ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=-dy_std*np.sin(rad(angle))*np.cos(rad(angle)), dy=dy_std*np.cos(rad(angle))*np.cos(rad(angle)), shape='full', lw=2, head_width=plot_width/50, color='grey')\n                ax.text(rect_bottom_centre_x - dy_std*np.sin(rad(angle)) - 8, rect_bottom_centre_y + dy_std*np.cos(rad(angle)) + 8, 'Normal', fontdict={'size':12})\n\n                # friction\n                ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=-mu*dy_std * np.cos(rad(angle))*np.cos(rad(angle)), dy=-mu*dy_std * np.sin(rad(angle))*np.cos(rad(angle)), shape='full', lw=2, head_width=plot_width/50, color='grey')\n                ax.text(rect_bottom_centre_x - mu*dy_std * np.cos(rad(angle)) - 10, rect_bottom_centre_y - mu*dy_std * np.sin(rad(angle)) - 10, 'friction', ha='left', fontdict={'size':12})        \n\n                # horizontal ocmponents\n                if angle > 0:\n                    ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=-dy_std*np.sin(rad(angle)), dy=0, shape='full', lw=2, head_width=plot_width/50, color='blue')\n                    ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=-mu*dy_std * np.cos(rad(angle)), dy=0, shape='full', lw=2, head_width=plot_width/50, color='red')\n\n\n                ax.set_xlim(0,plot_width)\n                ax.set_ylim(-40,plot_height)\n                ax.set_aspect('equal')\n                ax.axis('off')\n\n                return fig\n\n        with ui.card():\n            @render.text\n            def notesA():\n                return f\"Imagine the rectangle being a wheel on a vehicle, moving around a left corner, into the page.\"\n\n            @render.text\n            def notesB():\n                return \"The only force that would keep the wheel from going off the tangent and follow the circular path is provided by friction between the ground and the tyre.  This when the road is unbanked\"\n\n            @render.text\n            def notesC():\n                return \"Lets move the slider to increase angle to 10 degrees.  Now centripetal force as a result of friction has a lesser effect, but the horizontal component of the normal force comes into play.\"\n\n            @render.text\n            def notesD():\n                return \"Now centripetal force is the sum of the horizontal components of friction AND the normal force, which is greater than having just friction when the road is not banked.  Since centripetal force is proportional to the speed on a circular path, a vehicle can travel safely around a banked corner at higher speed without going off the road!\"\n\nui.nav_spacer()\n", "type": "text"}, {"name": "backup/app_20240427.py", "content": "from shiny.express import input, render, ui\nfrom shiny import reactive\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib.patches import Circle, Rectangle\nimport time\n\ntime_min: float = 0\ntime_max: float = 100\ntime_step: float = 1.5\n\nui.page_opts(title=\"Centripetal force\", fillable=True)\n\nwith ui.nav_panel(\"What is centripetal force?\"):\n    with ui.layout_sidebar():\n        with ui.sidebar(bg='#29e004'):\n            ui.input_slider(\"time\", \"Animate\", min=time_min, max=time_max,value=time_min, step=time_step, animate=True,)\n\n        with ui.card(height = 500):\n            def calc_pos(r: float, w: float, t: float) -> (float, float):\n                return r * np.cos(w * t), r* np.sin(w * t)\n\n            def calc_velocity_vector(r: float, w: float, t:float) -> (float, float):\n                return -w * r * np.sin(w * t), w * r * np.cos(w * t)\n\n            plot_width: float = 100.0\n            plot_height: float = 100.0\n            box_width: float = 30.0\n            box_height: float = 30.0\n            edge_color: str = 'green'\n            face_color: str = 'white'\n            path_radius: float = 80\n            obj_radius: float = 10\n            obj_lw: float = 5\n\n            fig_size: tuple = (10, 12)\n            obj_omega: float = 0.5 # angular velocity\n            lightgrey: list = ['#888888','#999999','#aaaaaa','#bbbbbb','#cccccc','#dddddd','#eeeeee','#ffffff']\n            \n            def create_circle(centre: (float,float), obj_radius: float, **kwargs) -> matplotlib.patches.Circle:\n                return Circle(centre, radius=obj_radius, lw=obj_lw, **kwargs)\n\n            centre_x: float = path_radius\n            centre_y: float = 0\n\n            x = np.linspace(-path_radius, path_radius, 100)\n            y = [np.sqrt(path_radius**2 - x_e**2) for x_e in x]\n            path_x = np.hstack([x, x[::-1]])\n            path_y = np.hstack([y,  [-1 * y_e for y_e in y][::-1]])\n\n            v_x: float = 0\n            v_y: float = obj_omega * path_radius\n\n            @reactive.effect\n            @reactive.event(input.time)\n            def set_pos() -> None:\n                # calculate centre_x and centre_y using input.time\n                global centre_x\n                global centre_y\n                \n                t: float = float(input.time())\n                centre_x, centre_y_new = calc_pos(path_radius, obj_omega, t)\n                if (centre_y_new > 0 and centre_y < 0) or ((input.time() - time_step) >= len(lightgrey)):\n                    centre_y = 0\n                    centre_x = path_radius\n                    ui.update_slider('time',value=0)\n                else:\n                    centre_y = centre_y_new\n\n            @reactive.effect\n            @reactive.event(input.time)\n            def set_velocity_vector() -> None:\n                global v_x\n                global v_y\n\n                t: float = float(input.time())\n                v_x, v_y = calc_velocity_vector(path_radius, obj_omega, t)\n\n            @render.plot\n            @reactive.event(input.time)\n            def plot() -> None:\n                # draw a small circle with a circular path\n                fig, ax = plt.subplots(figsize=fig_size)\n                ax.plot(path_x, path_y, lw=10, color='#f0ff0f', zorder=0)\n\n                t: float = float(input.time())\n                \n                counter = 0\n                n = t - time_step\n                while n > 0 and counter < len(lightgrey):\n                    grey_centre = calc_pos(path_radius, obj_omega, n)\n                    grey_circle = create_circle(grey_centre, obj_radius, facecolor = face_color, edgecolor =lightgrey[counter])\n                    ax.add_patch(grey_circle)\n                    \n                    grey_velocity = calc_velocity_vector(path_radius, obj_omega, n)\n                    ax.arrow(grey_centre[0] , grey_centre[1], dx=grey_velocity[0], dy=grey_velocity[1], shape='full', color=lightgrey[counter], lw=2, head_width=plot_width/50)\n                    n -= time_step\n                    counter += 1\n\n                circle = create_circle((centre_x, centre_y), obj_radius, facecolor = face_color, edgecolor = edge_color)\n                ax.add_patch(circle)\n\n                # demonsrate how centripetal acceleration points to the centre of the circel\n                if t == 0:\n                    xi, yi = calc_pos(path_radius, obj_omega, 1)\n                    v_xi, v_yi = calc_velocity_vector(path_radius, obj_omega, 1)\n                    # v(t)\n                    ax.arrow(xi , yi, dx=v_xi, dy=v_yi, shape='full', color=lightgrey[counter], ls='--', lw=1, head_width=plot_width/40)\n                    # v(0)\n                    ax.arrow(xi + v_xi , yi + v_yi, dx=-v_x, dy=-v_y, shape='full', color=lightgrey[counter], ls='--', lw=1, head_width=plot_width/40)\n\n                    ax.text((xi + v_xi) * 1.2, (yi + v_yi) * 0.8, 'v(t>0)', fontdict={'size':12,'fontweight':'bold'})\n                    ax.text((xi + v_xi) * 0.9, (yi + v_yi) * 0.8, '- v(t=0)', ha='right', fontdict={'size':12,'fontweight':'bold'})\n\n                    ax.arrow(xi, yi, dx = 0 - xi * 0.5, dy = 0 - yi * 0.5, color='grey', head_width = plot_width / 20)\n                    \n                ax.arrow(centre_x, centre_y, dx=v_x, dy=v_y, shape='full', lw=2, head_width=plot_width/50)\n\n                v_label: str = 'v(t=0)' if t == 0 else 'v'\n                ax.text((centre_x + v_x) / 0.9, (centre_y + v_y) * 0.8, v_label, fontdict={'size':12,'fontweight':'bold'})\n\n                ax.arrow(centre_x, centre_y, dx=0-centre_x, dy=0-centre_y, shape='full', lw=3, head_width=plot_width/30)\n                ax.text((centre_x + v_x/2)* 0.5, (centre_y + v_y/2) * 0.5, 'a', fontdict={'size':12,'fontweight':'bold'})\n\n                if t > 0:\n                    time_label = f't={input.time()}'\n                    ax.text(80,90, time_label, ha='left', fontdict={'size':12,'fontweight':'bold'})\n\n                ax.set_xlim(-plot_width,plot_width)\n                ax.set_ylim(-plot_height,plot_height)\n                ax.set_aspect('equal')\n                \n                ax.axis('off')\n\n                return fig\n\n        with ui.card():\n            @render.text\n            def notes1():\n                return \"Centripetal force is not a fundamental force.  It is an apparent force as a result of an object in motion following a circular path.\"\n\n            @render.text\n            def notes2():\n                return \"By definition acceleration is change in velocity with respect to time.  As an object moves along a circular path at constant speed its direction changes constantly.  This means that velocity is constantly changing in direction, resulting in acceleration.\"\n\n            @render.text\n            def notes3():\n                return \"By drawing the velocity vectors v at a point on the circular path and again after time t, it can easily be shown that the  acceleration points toward the centre of the circular path.\"\n\n            @render.text\n            def notes4():\n                return \"At any point on the path of a circular motion, the acceleration point toward the centre, hence the term, centripetal.\"\n\n            @render.text\n            def notes5():\n                return \"To understand why centripetal force exist we must consider Newton\u2019s law of inertia.  If no net force is present, an object moving at velocity v tangential to the circular path will continue its path in a straight line at constant speed.  In this case, there would be no circular motion.\"\n\n            @render.text\n            def notes6():\n                return \"In order to deviate from the straight line there must be a net force acting on the object.  This force pulls the object toward the centre to maintain the circular motion.\"\n\nwith ui.nav_panel('Banked corners'):\n\n    def calc_y(x: float, angle: float) -> None:\n        if  angle <= 60:\n            return np.tan(rad(angle)) * x\n\n    def rad(angle: float) -> float:\n        return angle / 180 * np.pi\n\n    with ui.layout_sidebar():        \n        with ui.sidebar(bg='#29e004'):\n\n            plot_width: float = 100.0\n            plot_height: float = 100.0\n            angle: float = 0\n            mu: float = 0.5\n            slope_x: np.array([float,float]) = np.array([0,100])\n            edge_color = 'black'\n            box_color = 'lightgrey'\n            box_height = 36\n            box_width = 15\n            anchor_x: float = (plot_width - box_width) / 2\n\n            ui.input_slider(\"angle_slider\", \"Angle\", min=0, max=60, value=angle, step=1)\n            ui.input_slider(\"mu_slider\", \"Coefficient of friction\", min=0, max=1, value=mu, step=0.01)\n\n        def create_rectangle(anchor_x: float, _anchor_y: float, width: float, height: float, angle: float, facecolor = face_color, edgecolor = edge_color) -> matplotlib.patches.Rectangle:\n            return Rectangle((anchor_x, _anchor_y), width, height, angle=angle, lw=5, facecolor = facecolor, edgecolor = edgecolor) #use rotation_point parameter default = 'xy' = bottom left corner (x, y) available in later matplotlive versions?\n\n        \n        @render.plot\n        @reactive.event(input.angle_slider, input.mu_slider)\n        def plot2() -> None:\n            angle: float = float(input.angle_slider())\n            mu: float = float(input.mu_slider())\n            \n            fig, ax = plt.subplots(figsize=(10,12))\n            print(int(input.angle_slider()))\n            ax.plot(slope_x, calc_y(slope_x, angle), lw=5, c='darkgrey', zorder=0)\n\n            x: float = anchor_x\n            y: float = calc_y(x, angle)\n\n            rect = create_rectangle(x, calc_y(anchor_x, angle), box_width, box_height, angle=angle, facecolor = box_color, edgecolor = edge_color) # angle in degrees\n            rect_bottom_centre_x = rect.get_x() + box_width/2 * np.cos(rad(angle))\n            rect_bottom_centre_y = calc_y(rect_bottom_centre_x, angle)\n\n            ax.add_patch(rect)\n\n            dy_std = 30\n\n            # weight\n            ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=0, dy=-dy_std, shape='full', lw=2, head_width=plot_width/50, color='grey')\n            ax.text(rect_bottom_centre_x + 2, rect_bottom_centre_y - 0.5 * dy_std, 'Weight', fontdict={'size':12})\n\n            # normal\n            ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=-dy_std*np.sin(rad(angle))*np.cos(rad(angle)), dy=dy_std*np.cos(rad(angle))*np.cos(rad(angle)), shape='full', lw=2, head_width=plot_width/50, color='grey')\n            ax.text(rect_bottom_centre_x - dy_std*np.sin(rad(angle)) - 8, rect_bottom_centre_y + dy_std*np.cos(rad(angle)) + 8, 'Normal', fontdict={'size':12})\n\n            # friction\n            ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=-mu*dy_std * np.cos(rad(angle))*np.cos(rad(angle)), dy=-mu*dy_std * np.sin(rad(angle))*np.cos(rad(angle)), shape='full', lw=2, head_width=plot_width/50, color='grey')\n            ax.text(rect_bottom_centre_x - mu*dy_std * np.cos(rad(angle)) - 10, rect_bottom_centre_y - mu*dy_std * np.sin(rad(angle)) - 10, 'friction', ha='left', fontdict={'size':12})        \n\n            # horizontal ocmponents\n            if angle > 0:\n                ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=-dy_std*np.sin(rad(angle)), dy=0, shape='full', lw=2, head_width=plot_width/50, color='blue')\n                ax.arrow(rect_bottom_centre_x, rect_bottom_centre_y, dx=-mu*dy_std * np.cos(rad(angle)), dy=0, shape='full', lw=2, head_width=plot_width/50, color='red')\n\n\n            ax.set_xlim(0,plot_width)\n            ax.set_ylim(-40,plot_height)\n            ax.set_aspect('equal')\n            ax.axis('off')\n\n            return fig\n\n        with ui.card():\n            @render.text\n            def notesA():\n                return f\"Imagine the rectangle being a wheel on a vehicle, moving around a left corner, into the page.\"\n\n            @render.text\n            def notesB():\n                return \"The only force that would keep the wheel from going off the tangent and follow the circular path is provided by friction between the ground and the tyre.  This when the road is unbanked\"\n\n            @render.text\n            def notesC():\n                return \"Lets move the slider to increase angle to 10 degrees.  Now centripetal force as a result of friction has a lesser effect, but the horizontal component of the normal force comes into play.\"\n\n            @render.text\n            def notesD():\n                return \"In general, direct contribution to centripetal force is much greater by the normal force is much greater than friction.  Now centripetal force is the sum of the horizontal components of friction AND the normal force, which is greater than when the road is not banked.  Since centripetal force is proportional to the speed on a circular path, a vehicle can travel safely around a banked corner at higher speed without going off the road!\"\n\nui.nav_spacer()\n", "type": "text"}]